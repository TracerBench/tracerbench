#!/usr/bin/env node
'use strict';

const Profile = require('../dist/index.cjs');
const program = require('commander');
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const SilentError = require('silent-error');
const d3 = require('d3');

function methodNames(val) {
  return val.split(',');
}

program
  .option('-f, --file <file>', 'Path to trace json file')
  .option('-m, --methods <names|file>', 'List of methods to aggregate', methodNames)
  .option('-r, --report <heuristicDir>', 'Generates a report with aggregated sums for each heuristic category and aggregated sum across all heuristics')
  .option('-t, --time <duration|eventName>', 'Slice time and see the events before and after the time slice')
  .parse(process.argv);

const error = chalk.bold.red;

let { file, methods, report, time } = program;
const defaultProfilePath = `${process.cwd()}/profile.json`;
const defaultMethodsPath = `${process.cwd()}/.methods.json}`;

if (file === undefined && fs.existsSync(defaultProfilePath) === false) {
  throw new SilentError(error(`Error: Must pass a path to the trace file ðŸ’£`));
}

let categories;

if (report) {
  let files = fs.readdirSync(report);
  categories = {};
  files.map(file => {
    let name = path.basename(file).replace('.json', '');
    let methods = JSON.parse(fs.readFileSync(`${report}/${file}`));
    categories[name] = methods;
  });
} else {

  if (methods === undefined && fs.existsSync(defaultMethodsPath) === false) {
    throw new SilentError(error(`Error: Must pass a list of method names or have a ".methods.json" file at the root of the project.`));
  }

  if (methods === undefined) {
    methods = JSON.parse(fs.readFileSync(defaultMethodsPath, 'utf8'));
  } else if (methods && fs.existsSync(process.cwd() + '/' + methods)) {
    methods = JSON.parse(fs.readFileSync(process.cwd() + '/' + methods, 'utf8'));
  }
}

const filePath = file || defaultProfilePath;
const traceEvents = JSON.parse(fs.readFileSync(filePath, 'utf8'));
const trace = Profile.loadTrace(traceEvents);
const profile = trace.cpuProfile;

const root = d3.hierarchy(profile.root, (node) => {
  if (node.children) {
    return node.children.map((id) => profile.nodes.get(id)).filter(node => node.callFrame.functionName !== '(idle)' && node.callFrame.functionName !== '(program)' && node.callFrame.functionName !== '(garbage collector)')
  }
}).sum(d => d.hitCount).sort((a, b) => {
  return b.value - a.value;
});

if (time) {
  let parsed = Number.parseInt(time);
  time = Number.isNaN(parsed) ? time : parsed;
}

let aggregator = new Profile.Aggregator(trace, root, time);
let reporter = new Profile.Reporter(aggregator);

if (program.report) {
  reporter.fullReport(categories);
} else {
  reporter.categoryReport(methods);
}
